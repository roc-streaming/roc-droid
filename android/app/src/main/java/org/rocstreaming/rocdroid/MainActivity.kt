package org.rocstreaming.rocdroid

import AndroidListener
import AndroidServiceError
import AndroidServiceEvent
import android.content.ComponentName
import android.content.Context.MEDIA_PROJECTION_SERVICE
import android.content.Intent
import android.content.ServiceConnection
import android.content.pm.PackageManager
import android.media.AudioManager
import android.media.projection.MediaProjection
import android.media.projection.MediaProjectionManager
import android.os.Bundle
import android.os.IBinder
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.activity.result.ActivityResult
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import io.flutter.embedding.android.FlutterFragmentActivity
import io.flutter.embedding.engine.FlutterEngine
import org.rocstreaming.rocdroid.AndroidConnectorImpl
import org.rocstreaming.rocdroid.StreamingEventListener
import org.rocstreaming.rocdroid.StreamingService

private const val LOG_TAG = "rocdroid.MainActivity"

class MainActivity: FlutterFragmentActivity() {
    // main activity is a singleton used by AndroidConnectorImpl
    companion object {
        lateinit var instance : MainActivity
    }

    // non-null once successfully connected to server
    // may temporarily become null when connection is lost
    private var service: StreamingService? = null

    fun getService() : StreamingService? {
        return service
    }

    // called when we've started the service and connected to it
    private var serviceStartedCallback: ((StreamingService) -> Unit)? = null

    // projectionRequestLauncher acquires access to projection from projectionManager
    // and invokes projectionRequestCallback
    private var projectionRequestCallback: ((MediaProjection?) -> Unit)? = null
    private lateinit var projectionRequestLauncher: ActivityResultLauncher<Intent>
    private lateinit var projectionManager: MediaProjectionManager

    // permissionRequestLauncher invokes permissionRequestCallback when
    // permission is granted or rejected
    private var permissionRequestCallback: ((Boolean) -> Unit)? = null
    private lateinit var permissionRequestLauncher: ActivityResultLauncher<String>

    // bridge to invoke dart methods from kotlin
    private lateinit var eventListener: AndroidListener

    // called at start
    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
        Log.d(LOG_TAG, "Configuring flutter engine")

        super.configureFlutterEngine(flutterEngine)

        // AndroidConnector interface is generated by pigeon and is called from dart
        // AndroidConnectorImpl implements its methods
        // here we link them together
        AndroidConnector.setUp(flutterEngine.dartExecutor.binaryMessenger,
                               AndroidConnectorImpl())

        // AndroidListener class is generated by pigeon and allows kotlin to
        // invoke dart methods
        eventListener = AndroidListener(flutterEngine.dartExecutor.binaryMessenger)
    }

    // when app is opened
    override fun onCreate(savedInstanceState: Bundle?) {
        Log.i(LOG_TAG, "Creating main activity")

        super.onCreate(savedInstanceState)

        instance = this

        // setup for permission requests
        permissionRequestLauncher = registerForActivityResult(
            ActivityResultContracts.RequestPermission(), this::onPermissionResult)

        // setup for projection request
        projectionManager = getSystemService(MEDIA_PROJECTION_SERVICE) as MediaProjectionManager
        projectionRequestLauncher = registerForActivityResult(
            ActivityResultContracts.StartActivityForResult(), this::onProjectionResult)
    }

    // when app is resumed
    override fun onResume() {
        Log.i(LOG_TAG, "Resuming main activity")

        super.onResume()
        volumeControlStream = AudioManager.STREAM_MUSIC
    }

    // when app is closed
    override fun onDestroy() {
        Log.i(LOG_TAG, "Destroying main activity")

        if (serviceConnection != null) {
            unbindService(serviceConnection)
        }

        super.onDestroy()
    }

    // start service if not started yet
    fun startService(callback: (StreamingService) -> Unit) {
        if (service != null) {
            Log.d(LOG_TAG, "Service already started, nothing to do")
            callback(service!!)
            return
        }

        Log.d(LOG_TAG, "Starting service")

        // callback will be invoked from onServiceConnected()
        serviceStartedCallback = callback

        val serviceIntent = Intent(this, StreamingService::class.java)
        startForegroundService(serviceIntent);
        bindService(serviceIntent, serviceConnection, BIND_AUTO_CREATE)
    }

    // handler for events produced by streaming service
    private val streamingEventHandler: StreamingEventListener = object : StreamingEventListener {
        override fun onEvent(event: AndroidServiceEvent) {
            Log.d(LOG_TAG, "Sending event: " + event.toString())
            runOnUiThread {
                eventListener.onEvent(event) { result -> }
            }
        }

        override fun onError(error: AndroidServiceError) {
            Log.d(LOG_TAG, "Sending error: " + error.toString())
            runOnUiThread {
                eventListener.onError(error) { result -> }
            }
        }
    }

    // handler for connect & disconnect events
    private val serviceConnection = object : ServiceConnection {
        // called when we've successfully connected to the service
        override fun onServiceConnected(componentName: ComponentName, binder: IBinder) {
            Log.i(LOG_TAG, "Service connected")

            // remember service reference
            service = (binder as StreamingService.LocalBinder).getService()
            service?.setEventListener(streamingEventHandler)

            // for startService()
            serviceStartedCallback?.invoke(service!!)
            serviceStartedCallback = null
        }

        // called when we've lost connectio to service
        override fun onServiceDisconnected(componentName: ComponentName) {
            Log.w(LOG_TAG, "Service disconnected")

            // forget service reference
            service?.removeEventListener()
            service = null

            // (re)start & reconnect
            Log.d(LOG_TAG, "Initiating asynchronous reconnect")
            val serviceIntent = Intent(this@MainActivity, StreamingService::class.java)
            startForegroundService(serviceIntent);
            bindService(serviceIntent, this, BIND_AUTO_CREATE)
        }
    }

    fun requestProjection(callback: (MediaProjection?) -> Unit) {
        Log.d(LOG_TAG, "Issuing media projection request")

        // callback will be invoked from onProjectionResult()
        val projectionIntent = projectionManager.createScreenCaptureIntent()
        projectionRequestCallback = callback
        projectionRequestLauncher.launch(projectionIntent)
    }

    private fun onProjectionResult(result: ActivityResult) {
        if (result.data != null) {
            Log.d(LOG_TAG, "Media projection acquired with code " + result.resultCode.toString());
            val projection = projectionManager.getMediaProjection(result.resultCode, result.data!!)
            projectionRequestCallback?.invoke(projection)
            projectionRequestCallback = null
        } else {
            Log.d(LOG_TAG, "Media projection rejected with code " + result.resultCode.toString());
            projectionRequestCallback?.invoke(null)
            projectionRequestCallback = null
        }
    }

    fun hasPermission(permission: String): Boolean {
        return ContextCompat.checkSelfPermission(this, permission) == PackageManager.PERMISSION_GRANTED
    }

    fun requestPermission(permission: String, titleID: Int, messageID: Int, callback: (Boolean) -> Unit) {
        if (ContextCompat.checkSelfPermission(this, permission) == PackageManager.PERMISSION_GRANTED) {
            Log.d(LOG_TAG, "Permission already granted, nothing to do")
            callback(true)
            return
        }

        if (shouldShowRequestPermissionRationale(permission)) {
            Log.d(LOG_TAG, "Showing permission dialog and waiting for response")
            AlertDialog.Builder(this).apply {
                setTitle(titleID)
                setMessage(messageID)
                setPositiveButton(R.string.ok) { _, _ ->
                    Log.d(LOG_TAG, "User approved permission, issuing request")
                    // callback will be invoked from onPermissionResult()
                    permissionRequestCallback = callback
                    permissionRequestLauncher.launch(permission)
                }
                setNegativeButton(R.string.cancel) { dialog, _ ->
                    Log.w(LOG_TAG, "User declined permission, rejecting")
                    dialog.dismiss()
                    callback(false)
                }
            }.show()
        } else {
            Log.d(LOG_TAG, "Requesting permission directly")
            // callback will be invoked from onPermissionResult()
            permissionRequestCallback = callback
            permissionRequestLauncher.launch(permission)
        }
    }

    private fun onPermissionResult(isGranted: Boolean) {
        if (isGranted) {
            Log.d(LOG_TAG, "Permission is granted");
        } else {
            Log.w(LOG_TAG, "Permission is rejected");
        }
        permissionRequestCallback?.invoke(isGranted)
        permissionRequestCallback = null
    }
}
